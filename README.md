# UltraRust

<div align="center">

**A Hardened Rust Pipeline for AI-Generated Code**

[![Rust](https://img.shields.io/badge/rust-%23000000.svg?style=for-the-badge&logo=rust&logoColor=white)](https://www.rust-lang.org/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

*Ensuring AI-generated Rust code meets the highest standards of quality, security, and safety.*

[Features](#features) â€¢ [Installation](#installation) â€¢ [Usage](#usage) â€¢ [Configuration](#configuration) â€¢ [Why UltraRust?](#why-ultrarust)

</div>

---

## What is UltraRust?

UltraRust is a comprehensive **3-stage verification pipeline** specifically designed to analyze and validate Rust code generated by AI systems. While modern AI can write impressive code, it often lacks the rigorous safety, security, and quality checks that production Rust demands. UltraRust fills this gap by providing automated, thorough analysis across multiple dimensions.

### The Three Stages

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stage 1: Supply    â”‚  Verify dependencies are secure and trustworthy
â”‚  Chain Security     â”‚  â€¢ cargo-audit: CVE detection
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â€¢ cargo-deny: Policy enforcement
           â”‚             â€¢ cargo-geiger: Unsafe code analysis
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stage 2: Compile   â”‚  Enforce strict code quality standards
â”‚  & Lint Checks      â”‚  â€¢ 70+ Clippy lints at deny level
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â€¢ 5 custom lints for AI-specific issues
           â”‚             â€¢ Zero warnings policy
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stage 3: Security  â”‚  Deep security analysis via AST inspection
â”‚  Analysis           â”‚  â€¢ 10 security checks for common vulnerabilities
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â€¢ Pattern matching for dangerous code
           â”‚             â€¢ Taint tracking for injection attacks
           â–¼
      âœ… Pass/Fail
```

## Why UltraRust?

### The Problem

AI-generated code, while increasingly sophisticated, faces several challenges:

1. **Security Blind Spots**: AI models may generate code with subtle security vulnerabilities (hardcoded secrets, timing attacks, SQL injection patterns)
2. **Unsafe Dependencies**: AI doesn't verify supply chain security or check for CVEs in suggested crates
3. **Quality Inconsistency**: AI-generated code may compile but violate best practices, have hidden complexity, or use anti-patterns
4. **Trust Gap**: Teams need confidence that AI-generated code meets the same standards as human-written code

### The Solution

UltraRust was created to bridge the trust gap between AI code generation and production deployment. It acts as an automated code reviewer that:

- **Never misses a check**: Runs exhaustive analysis on every commit
- **Catches what AI misses**: Identifies patterns and vulnerabilities AI models aren't trained to avoid
- **Enforces consistency**: Applies the same rigorous standards to all code, regardless of origin
- **Provides confidence**: Clear pass/fail verdict with detailed findings for remediation

## Features

### ğŸ”’ Stage 1: Supply Chain Security

Analyzes your dependencies for security and safety issues:

- **CVE Detection**: Scans for known vulnerabilities using `cargo-audit`
- **Policy Enforcement**: Validates licenses, sources, and dependency rules via `cargo-deny`
- **Unsafe Code Analysis**: Measures unsafe code usage in dependencies with `cargo-geiger`
- **Threshold Configuration**: Set acceptable limits for unsafe code in direct and transitive dependencies

### ğŸ¯ Stage 2: Compile & Lint Checks

Enforces strict code quality with over 70 lints:

- **Restriction Lints**: Bans dangerous patterns (unwrap, panic, exit, indexing)
- **Pedantic Lints**: Enforces best practices and idiomatic code
- **5 Custom Lints**:
  - `no_interior_mutability`: Prevents `RefCell`, `Cell`, `UnsafeCell` usage
  - `no_string_errors`: Bans `Result<T, String>` error types
  - `no_infinite_loops`: Detects loops without break conditions
  - `public_api_lifetimes`: Requires explicit lifetimes on public functions
  - `bounded_generics`: Limits type parameter complexity (max 4)

### ğŸ›¡ï¸ Stage 3: Security Analysis

Deep security scanning via AST analysis:

1. **Hardcoded Secrets Detection**
   - Regex patterns for API keys, tokens, passwords
   - Shannon entropy analysis for high-entropy strings
   - Detects AWS keys, GitHub tokens, OpenAI keys, and more

2. **Command Injection Prevention**
   - Taint tracking from user input to `Command::arg()`
   - Flags unsanitized input in shell commands

3. **Path Traversal Detection**
   - Tracks tainted paths through `Path::join()`
   - Prevents directory traversal attacks

4. **Weak Cryptography Detection**
   - Bans MD5, SHA1, DES, RC4, ECB mode
   - Recommends secure alternatives

5. **Insecure Deserialization**
   - Flags unbounded `serde_json` deserialization
   - Prevents DoS via oversized payloads

6. **SQL Injection Detection**
   - Identifies format strings in SQL queries
   - Recommends parameterized queries

7. **Unbounded Reads**
   - Detects `read_to_string()` without size limits
   - Prevents memory exhaustion attacks

8. **Insecure TLS Configuration**
   - Flags disabled certificate validation
   - Identifies dangerous TLS settings

9. **Insecure Random Number Generation**
   - Detects `thread_rng()` in security contexts
   - Recommends `OsRng` for cryptographic use

10. **Timing Attack Vulnerabilities**
    - Flags non-constant-time comparisons on secrets
    - Recommends `constant_time_eq` or `subtle::ConstantTimeEq`

### ğŸ“Š Output Formats

- **Human-Readable Summary**: Colored terminal output with severity levels
- **Structured JSON**: Machine-parseable output for CI/CD integration
- **Detailed Findings**: File paths, line numbers, descriptions, and fix recommendations

## Installation

### Prerequisites

- Rust 1.70+ (for the tool itself)
- `cargo-audit`, `cargo-deny`, `cargo-geiger` (for Stage 1)

### Install UltraRust

```bash
cargo install --git https://github.com/OutsideTheBoxIdeas/UltraRust --branch UltraRust
```

### Install Supply Chain Tools

```bash
cargo install cargo-audit cargo-deny cargo-geiger
```

## Usage

### Basic Usage

Analyze a Rust project in the current directory:

```bash
ultrarust
```

Analyze a specific project:

```bash
ultrarust /path/to/project
```

### Verbose Output

See detailed progress and debug information:

```bash
ultrarust --verbose
```

### JSON Output

Get structured output for CI/CD pipelines:

```bash
ultrarust --json > report.json
```

### Run Specific Stages

Run only supply chain checks:

```bash
ultrarust --stage supply-chain
```

Run only lint checks:

```bash
ultrarust --stage lint
```

Run only security analysis:

```bash
ultrarust --stage security
```

### Custom Configuration

Specify a custom config file:

```bash
ultrarust --config ultrarust.toml
```

## Configuration

UltraRust can be configured via your project's `Cargo.toml`:

```toml
[package.metadata.ultrarust]
# Code quality thresholds
max-complexity = 12           # Maximum cognitive complexity per function
max-function-lines = 80       # Maximum lines per function
max-parameters = 5            # Maximum function parameters
max-generic-depth = 4         # Maximum generic type parameters
max-nesting = 4               # Maximum nesting depth

# Supply chain thresholds
geiger-unsafe-threshold = 0          # Max unsafe in direct deps (0 = none allowed)
geiger-transitive-threshold = 50     # Max unsafe in transitive deps

# Stage toggles
security-checks = true        # Enable/disable Stage 3
supply-chain-checks = true    # Enable/disable Stage 1
```

### External Configuration File

Create a standalone `ultrarust.toml`:

```toml
max-complexity = 15
max-function-lines = 100
security-checks = true
supply-chain-checks = true
geiger-unsafe-threshold = 0
geiger-transitive-threshold = 100
```

Use it with:

```bash
ultrarust --config ultrarust.toml
```

## Exit Codes

- `0`: All checks passed âœ…
- `1`: One or more checks failed âŒ
- `2`: Tool error (missing dependencies, invalid config, etc.)

## CI/CD Integration

### GitHub Actions

```yaml
name: UltraRust Analysis

on: [push, pull_request]

jobs:
  ultrarust:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable

      - name: Install UltraRust & Tools
        run: |
          cargo install --git https://github.com/OutsideTheBoxIdeas/UltraRust --branch UltraRust
          cargo install cargo-audit cargo-deny cargo-geiger

      - name: Run UltraRust
        run: ultrarust --verbose
```

### GitLab CI

```yaml
ultrarust:
  image: rust:latest
  script:
    - cargo install --git https://github.com/OutsideTheBoxIdeas/UltraRust --branch UltraRust
    - cargo install cargo-audit cargo-deny cargo-geiger
    - ultrarust --json > report.json
  artifacts:
    reports:
      junit: report.json
    paths:
      - report.json
```

## Example Output

```
=== UltraRust v1.0.0 - FAIL ===

Stage 1 (Supply Chain): PASS | vulns: 0 | banned: 0 | unsafe deps: 0
Stage 2 (Compile+Lint):  FAIL | violations: 12
Stage 3 (Security):     FAIL | findings: 3

Total issues: 15 (critical: 2, high: 10, medium: 3)

--- Security Findings ---
  [critical] hardcoded_secrets at src/api.rs:42:18
    Hardcoded AWS Access Key detected in string literal.
    > "AKIAIOSFODNN7EXAMPLE"
    fix: Load from environment variable or secret manager. Never hardcode secrets.

  [high] timing_attack at src/auth.rs:88:12
    Non-constant-time comparison (`==`) on secret-like variable `password`.
    > password == stored
    fix: Use `constant_time_eq` or `subtle::ConstantTimeEq` for comparing secrets.

  [medium] unbounded_reads at src/parser.rs:156:22
    Unbounded `read_to_string()` call. This reads the entire file into memory.
    > fs::read_to_string(path)
    fix: Check file size before reading, or use a bounded reader.
```

## Development Status

UltraRust is actively maintained and tested against real-world AI-generated code. Current version: **1.0.0**

### Test Coverage

- **171 passing tests** (70 lib unit tests + 70 bin unit tests + 31 integration tests)
- **Zero unsafe code** in the implementation
- **Self-hosting**: UltraRust can analyze itself

## Why I Created UltraRust

As AI code generation becomes increasingly prevalent in software development, I recognized a critical gap: **trust and verification**. While AI tools like ChatGPT, Claude, and GitHub Copilot can generate impressive Rust code, they lack the contextual awareness and security consciousness required for production systems.

### The Inspiration

After working extensively with AI-generated Rust code, I noticed recurring patterns:

1. **Security vulnerabilities** that compiled fine but introduced subtle risks (hardcoded credentials, timing attacks, weak crypto)
2. **Dependency blind spots** where AI would suggest crates without checking for CVEs or unsafe code
3. **Quality inconsistencies** where generated code worked but violated Rust idioms or best practices
4. **Trust barriers** preventing teams from confidently deploying AI-generated code

### The Vision

UltraRust embodies a simple principle: **AI-generated code should meet or exceed the standards we apply to human-written code.** By automating rigorous, multi-layered analysis, UltraRust enables developers to:

- **Embrace AI assistance** without compromising security or quality
- **Ship faster** with confidence in automated verification
- **Learn from findings** as UltraRust highlights issues and suggests fixes
- **Maintain standards** consistently across codebases

### The Goal

My goal is to make UltraRust the **de facto standard for validating AI-generated Rust code**, providing a trustworthy bridge between AI's impressive generation capabilities and production-ready, secure software.

## Contributing

Contributions are welcome! Areas for improvement:

- Additional security checks
- More custom lints
- IDE integrations
- Enhanced reporting formats

## License

MIT License - See [LICENSE](LICENSE-MIT) for details.

## Acknowledgments

- Built with [syn](https://github.com/dtolnay/syn) for Rust AST analysis
- Integrates [cargo-audit](https://github.com/rustsec/rustsec), [cargo-deny](https://github.com/EmbarkStudios/cargo-deny), and [cargo-geiger](https://github.com/geiger-rs/cargo-geiger)
- Inspired by the Rust community's commitment to safety and correctness

---

<div align="center">

**Built with ğŸ¦€ by developers who believe AI-generated code should be as trustworthy as human-written code.**

[Report a Bug](https://github.com/OutsideTheBoxIdeas/UltraRust/issues) â€¢ [Request a Feature](https://github.com/OutsideTheBoxIdeas/UltraRust/issues) â€¢ [Documentation](https://github.com/OutsideTheBoxIdeas/UltraRust)

</div>
