# UltraRust

<div align="center">

**A Hardened Rust Pipeline for AI-Generated Code**

[![Rust](https://img.shields.io/badge/rust-%23000000.svg?style=for-the-badge&logo=rust&logoColor=white)](https://www.rust-lang.org/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

*Ensuring AI-generated Rust code meets the highest standards of quality, security, and safety.*

[Example Report](#-example-report-generated-by-ultrarust) â€¢ [Features](#features) â€¢ [Installation](#installation) â€¢ [Usage](#usage) â€¢ [Configuration](#configuration) â€¢ [Why UltraRust?](#why-ultrarust)

</div>

---

## ğŸš¨ Example Report (Generated by UltraRust)

> [!WARNING]
> **Overall Status: FAIL**  
> **Generated:** 2026-02-15 17:19:27 | UltraRust v1.0.0  
> **Project:** `sample-rust-project`

### Some of these will be false positives. The point is to feed the findings .json back into your prefered AI model and have it check all of these to see what findings are genuine and fix them


| Total Findings | Critical | High | Medium | Low |
| ---: | ---: | ---: | ---: | ---: |
| **765** | **110** | **294** | **361** | **0** |

### Stage Breakdown

| Stage | Status | Result |
| --- | --- | --- |
| Stage 1: Supply Chain | âŒ FAIL | 2 vulnerabilities |
| Stage 2: Compile + Lint | âŒ FAIL | 11 violations |
| Stage 3: Security | âŒ FAIL | 752 findings |

```text
=== UltraRust v1.0.0 - FAIL ===

Stage 1 (Supply Chain): FAIL | vulns: 2 | banned: 0 | unsafe deps: 0
Stage 2 (Compile+Lint):  FAIL | violations: 11
Stage 3 (Security):      FAIL | findings: 752

Total issues: 765 (critical: 110, high: 294, medium: 361, low: 0)
```

### Critical Findings Snapshot

- **RUSTSEC-2026-0007**: Integer overflow in `BytesMut::reserve` (`bytes@1.11.0`)
- **RUSTSEC-2026-0009**: Stack exhaustion DoS (`time@0.3.45`)
- **Command injection** findings where unsanitized input reaches `.arg()`/`.args()`
- **Path traversal** findings where tainted input reaches `.join()`/`.push()`

### Detailed Breakdown (Paths Redacted)

#### Compile + Lint Violations (11)

| Check | Count | Description |
| --- | ---: | --- |
| `renamed_and_removed_lints` | 1 | Deprecated lint name used; update to current Clippy lint name |
| `clippy::allow_attributes` | 1 | `#[allow(...)]` attribute detected under strict policy |
| `clippy::str_to_string` | 6 | `to_string()` on string literals instead of `String::from(...)` |
| `clippy::missing_errors_doc` | 3 | Public `Result`-returning methods missing `# Errors` docs |

#### Security Findings by Category (752)

| Category | Severity | Count | Representative Pattern (Redacted) |
| --- | --- | ---: | --- |
| `insecure_deserialization` | Medium | 267 | `serde_json::from_str(unbounded_input)` |
| `unbounded_reads` | High | 178 | `fs::read_to_string(unvalidated_path)` |
| `hardcoded_secrets` | High | 105 | High-entropy string literals in source |
| `public_api_lifetimes` | Medium | 92 | Public APIs with elided lifetimes |
| `path_traversal` | Critical | 86 | `base.join(tainted_component)` |
| `command_injection` | Critical | 21 | `Command::new(...).arg(tainted_input)` |
| `no_string_errors` | Medium | 2 | `Result<T, String>` in public-facing code |
| `no_infinite_loops` | High | 1 | Unconditional `loop { ... }` without reachable exit |

#### Representative Findings (Sanitized)

- **Dependency risk:** vulnerable transitive crates flagged by RustSec advisories.
- **CLI execution paths:** command arguments constructed from unchecked runtime input.
- **Filesystem operations:** untrusted path segments appended without canonical boundary checks.
- **Config/data parsing:** large JSON/YAML payloads deserialized without explicit size limits.
- **API quality:** exported methods missing explicit lifetime and error documentation requirements.

> [!NOTE]
> This section intentionally omits concrete folder and file paths so the example can be shared safely in public documentation.

---

## What is UltraRust?

UltraRust is a comprehensive **3-stage verification pipeline** specifically designed to analyze and validate Rust code generated by AI systems. While modern AI can write impressive code, it often lacks the rigorous safety, security, and quality checks that production Rust demands. UltraRust fills this gap by providing automated, thorough analysis across multiple dimensions.

> **Important:** UltraRust does **not** modify or replace the official Rust compiler (`rustc`). This is a standalone validation tool that runs additional automated checks on top of the standard Rust compilation process. Think of it as an extra safety net that sits alongside your normal Rust toolchain.

### âš ï¸ Early Release Notice

This project was created with **Claude Opus 4.6 and Sonnet 4.5** as a proof-of-concept to demonstrate what's possible when AI builds tools for validating AI-generated code. While the implementation is functional and passes all tests, **this is an early release that needs real-world testing.**

The goal is to:

**We need your help!** If you work with AI-generated Rust code, please:
1. Test UltraRust on your projects
2. Report issues and edge cases you discover
3. Share your results and use cases
4. Contribute improvements and additional checks
5. Help spread the word if you find this useful

Together, we can build the best possible validator for AI-written Rust code. This is just the starting point.

### The Three Stages

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stage 1: Supply    â”‚  Verify dependencies are secure and trustworthy
â”‚  Chain Security     â”‚  â€¢ cargo-audit: CVE detection
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â€¢ cargo-deny: Policy enforcement
           â”‚             â€¢ cargo-geiger: Unsafe code analysis
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stage 2: Compile   â”‚  Enforce strict code quality standards
â”‚  & Lint Checks      â”‚  â€¢ 70+ Clippy lints at deny level
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â€¢ 5 custom lints for AI-specific issues
           â”‚             â€¢ Zero warnings policy
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stage 3: Security  â”‚  Deep security analysis via AST inspection
â”‚  Analysis           â”‚  â€¢ 10 security checks for common vulnerabilities
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â€¢ Pattern matching for dangerous code
           â”‚             â€¢ Taint tracking for injection attacks
           â–¼
      âœ… Pass/Fail
```

## Why UltraRust?

### The Problem

AI-generated code, while increasingly sophisticated, faces several challenges:

1. **Security Blind Spots**: AI models may generate code with subtle security vulnerabilities (hardcoded secrets, timing attacks, SQL injection patterns)
2. **Unsafe Dependencies**: AI doesn't verify supply chain security or check for CVEs in suggested crates
3. **Quality Inconsistency**: AI-generated code may compile but violate best practices, have hidden complexity, or use anti-patterns
4. **Trust Gap**: Teams need confidence that AI-generated code meets the same standards as human-written code

### The Solution

UltraRust was created to bridge the trust gap between AI code generation and production deployment. It acts as an automated code reviewer that:

- **Never misses a check**: Runs exhaustive analysis on every commit
- **Catches what AI misses**: Identifies patterns and vulnerabilities AI models aren't trained to avoid
- **Enforces consistency**: Applies the same rigorous standards to all code, regardless of origin
- **Provides confidence**: Clear pass/fail verdict with detailed findings for remediation

## Features

### ğŸ”’ Stage 1: Supply Chain Security

Analyzes your dependencies for security and safety issues:

- **CVE Detection**: Scans for known vulnerabilities using `cargo-audit`
- **Policy Enforcement**: Validates licenses, sources, and dependency rules via `cargo-deny`
- **Unsafe Code Analysis**: Measures unsafe code usage in dependencies with `cargo-geiger`
- **Threshold Configuration**: Set acceptable limits for unsafe code in direct and transitive dependencies

### ğŸ¯ Stage 2: Compile & Lint Checks

Enforces strict code quality with over 70 lints:

- **Restriction Lints**: Bans dangerous patterns (unwrap, panic, exit, indexing)
- **Pedantic Lints**: Enforces best practices and idiomatic code
- **5 Custom Lints**:
  - `no_interior_mutability`: Prevents `RefCell`, `Cell`, `UnsafeCell` usage
  - `no_string_errors`: Bans `Result<T, String>` error types
  - `no_infinite_loops`: Detects loops without break conditions
  - `public_api_lifetimes`: Requires explicit lifetimes on public functions
  - `bounded_generics`: Limits type parameter complexity (max 4)

### ğŸ›¡ï¸ Stage 3: Security Analysis

Deep security scanning via AST analysis:

1. **Hardcoded Secrets Detection**
   - Regex patterns for API keys, tokens, passwords
   - Shannon entropy analysis for high-entropy strings
   - Detects AWS keys, GitHub tokens, OpenAI keys, and more

2. **Command Injection Prevention**
   - Taint tracking from user input to `Command::arg()`
   - Flags unsanitized input in shell commands

3. **Path Traversal Detection**
   - Tracks tainted paths through `Path::join()`
   - Prevents directory traversal attacks

4. **Weak Cryptography Detection**
   - Bans MD5, SHA1, DES, RC4, ECB mode
   - Recommends secure alternatives

5. **Insecure Deserialization**
   - Flags unbounded `serde_json` deserialization
   - Prevents DoS via oversized payloads

6. **SQL Injection Detection**
   - Identifies format strings in SQL queries
   - Recommends parameterized queries

7. **Unbounded Reads**
   - Detects `read_to_string()` without size limits
   - Prevents memory exhaustion attacks

8. **Insecure TLS Configuration**
   - Flags disabled certificate validation
   - Identifies dangerous TLS settings

9. **Insecure Random Number Generation**
   - Detects `thread_rng()` in security contexts
   - Recommends `OsRng` for cryptographic use

10. **Timing Attack Vulnerabilities**
    - Flags non-constant-time comparisons on secrets
    - Recommends `constant_time_eq` or `subtle::ConstantTimeEq`

### ğŸ“Š Output Formats

- **Human-Readable Summary**: Colored terminal output with severity levels
- **Structured JSON**: Machine-parseable output for CI/CD integration
- **Detailed Findings**: File paths, line numbers, descriptions, and fix recommendations

## Installation

### Prerequisites

- Rust 1.70+ (for the tool itself)
- `cargo-audit`, `cargo-deny`, `cargo-geiger` (for Stage 1)

### Install UltraRust

```bash
cargo install --git https://github.com/OutsideTheBoxIdeas/UltraRust --branch UltraRust
```

### Install Supply Chain Tools

```bash
cargo install cargo-audit cargo-deny cargo-geiger
```

## Usage

### Basic Usage

Analyze a Rust project in the current directory:

```bash
ultrarust
```

Analyze a specific project:

```bash
ultrarust /path/to/project
```

### Verbose Output

See detailed progress and debug information:

```bash
ultrarust --verbose
```

### JSON Output

Get structured output for CI/CD pipelines:

```bash
ultrarust --json > report.json
```

### Run Specific Stages

Run only supply chain checks:

```bash
ultrarust --stage supply-chain
```

Run only lint checks:

```bash
ultrarust --stage lint
```

Run only security analysis:

```bash
ultrarust --stage security
```

### Custom Configuration

Specify a custom config file:

```bash
ultrarust --config ultrarust.toml
```

## Configuration

UltraRust can be configured via your project's `Cargo.toml`:

```toml
[package.metadata.ultrarust]
# Code quality thresholds
max-complexity = 12           # Maximum cognitive complexity per function
max-function-lines = 80       # Maximum lines per function
max-parameters = 5            # Maximum function parameters
max-generic-depth = 4         # Maximum generic type parameters
max-nesting = 4               # Maximum nesting depth

# Supply chain thresholds
geiger-unsafe-threshold = 0          # Max unsafe in direct deps (0 = none allowed)
geiger-transitive-threshold = 50     # Max unsafe in transitive deps

# Stage toggles
security-checks = true        # Enable/disable Stage 3
supply-chain-checks = true    # Enable/disable Stage 1
```

### External Configuration File

Create a standalone `ultrarust.toml`:

```toml
max-complexity = 15
max-function-lines = 100
security-checks = true
supply-chain-checks = true
geiger-unsafe-threshold = 0
geiger-transitive-threshold = 100
```

Use it with:

```bash
ultrarust --config ultrarust.toml
```

## Exit Codes

- `0`: All checks passed âœ…
- `1`: One or more checks failed âŒ
- `2`: Tool error (missing dependencies, invalid config, etc.)

## CI/CD Integration

### GitHub Actions

```yaml
name: UltraRust Analysis

on: [push, pull_request]

jobs:
  ultrarust:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable

      - name: Install UltraRust & Tools
        run: |
          cargo install --git https://github.com/OutsideTheBoxIdeas/UltraRust --branch UltraRust
          cargo install cargo-audit cargo-deny cargo-geiger

      - name: Run UltraRust
        run: ultrarust --verbose
```

### GitLab CI

```yaml
ultrarust:
  image: rust:latest
  script:
    - cargo install --git https://github.com/OutsideTheBoxIdeas/UltraRust --branch UltraRust
    - cargo install cargo-audit cargo-deny cargo-geiger
    - ultrarust --json > report.json
  artifacts:
    reports:
      junit: report.json
    paths:
      - report.json
```

## Example Output

```
=== UltraRust v1.0.0 - FAIL ===

Stage 1 (Supply Chain): PASS | vulns: 0 | banned: 0 | unsafe deps: 0
Stage 2 (Compile+Lint):  FAIL | violations: 12
Stage 3 (Security):     FAIL | findings: 3

Total issues: 15 (critical: 2, high: 10, medium: 3)

--- Security Findings ---
  [critical] hardcoded_secrets at src/api.rs:42:18
    Hardcoded AWS Access Key detected in string literal.
    > "AKIAIOSFODNN7EXAMPLE"
    fix: Load from environment variable or secret manager. Never hardcode secrets.

  [high] timing_attack at src/auth.rs:88:12
    Non-constant-time comparison (`==`) on secret-like variable `password`.
    > password == stored
    fix: Use `constant_time_eq` or `subtle::ConstantTimeEq` for comparing secrets.

  [medium] unbounded_reads at src/parser.rs:156:22
    Unbounded `read_to_string()` call. This reads the entire file into memory.
    > fs::read_to_string(path)
    fix: Check file size before reading, or use a bounded reader.
```

## Development Status

**Current Status:** Early experimental release (v1.0.0)

UltraRust was built as a proof-of-concept in collaboration with Claude Opus 4.6 to demonstrate what's achievable when AI helps build tools for validating AI-generated code. The implementation is functional and passes internal tests, but **needs extensive real-world validation** before being considered production-ready.

### What Works Today

- **171 passing tests** (70 lib unit tests + 70 bin unit tests + 31 integration tests)
- **Zero unsafe code** in the implementation
- **Self-hosting**: UltraRust can analyze itself
- **Functional pipeline**: All three stages execute correctly

### What Needs Validation

- **Real-world edge cases**: We need testing on diverse AI-generated codebases
- **Performance at scale**: How does it handle large projects?
- **False positive rate**: Are the security checks too aggressive or not aggressive enough?
- **Lint rule effectiveness**: Do the custom lints catch the right issues?
- **Integration friction**: How well does it fit into existing workflows?

**Your testing and feedback will directly shape the future of this tool.**

## Why UltraRust Was Created

As AI code generation becomes increasingly prevalent in software development, a critical gap emerged: **trust and verification**. While AI tools like ChatGPT, Claude, and GitHub Copilot can generate impressive Rust code, they lack the contextual awareness and security consciousness required for production systems.

UltraRust represents an experiment in using AI (Claude Opus 4.6) to build the very validation tools we need for AI-generated code. This is a human-AI collaboration where the human identified the problem space and requirements, and the AI designed and implemented the solution. The result demonstrates both the potential and the limitations of AI-assisted development.

### The Inspiration

After working extensively with AI-generated Rust code, I noticed recurring patterns:

1. **Security vulnerabilities** that compiled fine but introduced subtle risks (hardcoded credentials, timing attacks, weak crypto)
2. **Dependency blind spots** where AI would suggest crates without checking for CVEs or unsafe code
3. **Quality inconsistencies** where generated code worked but violated Rust idioms or best practices
4. **Trust barriers** preventing teams from confidently deploying AI-generated code

### The Vision

UltraRust embodies a simple principle: **AI-generated code should meet or exceed the standards we apply to human-written code.** By automating rigorous, multi-layered analysis, UltraRust enables developers to:

- **Embrace AI assistance** without compromising security or quality
- **Ship faster** with confidence in automated verification
- **Learn from findings** as UltraRust highlights issues and suggests fixes
- **Maintain standards** consistently across codebases

### The Goal

The vision is for UltraRust (or something inspired by it) to become a **de facto standard for validating AI-generated Rust code**, providing a trustworthy bridge between AI's impressive generation capabilities and production-ready, secure software.

But here's the thing: **this is just the first iteration**. An idea implemented quickly to get it into your hands. The real goal is to spark a movement in the Rust community to take AI code validation seriously and collaboratively build the best possible solution. Whether that's UltraRust evolving with community input, or this project inspiring better alternativesâ€”either outcome would be a win.

## ğŸš€ Help Us Validate This Idea

UltraRust is an experiment released early to gather real-world feedback. **We need your help to determine if this approach works and where it needs to improve.**

### How You Can Help

**1. Test It**
   - Run UltraRust on AI-generated code you're working with
   - Try it on different types of projects (CLI tools, web servers, embedded systems)
   - See if it catches issues your normal workflow misses

**2. Report Your Experience**
   - Did it find legitimate issues? False positives?
   - How long did it take to run?
   - Did any checks feel too strict or not strict enough?
   - What's missing that you'd want to see?

**3. Share Results**
   - If UltraRust helps you catch real bugs or security issues, share your story
   - Tweet, blog, or discuss in Rust community forums
   - Help us understand which checks provide the most value

**4. Spread the Word**
   - If you think this idea has merit, tell other Rust developers
   - The faster we get feedback, the faster we can improve it
   - Star the repo if you want to see this project evolve

**5. Contribute Code**
   - Add new security checks you've seen AI miss
   - Improve existing lints based on your experience
   - Help optimize performance for large codebases

### What Success Looks Like

Success isn't about UltraRust specificallyâ€”it's about the Rust community having **effective, accessible tools** to validate AI-generated code. If this project inspires you to build something better, or if our approach identifies gaps in existing tools, that's success.

We're not asking for blind adoption. We're asking for critical evaluation and honest feedback so we can collectively figure out what good AI code validation looks like for Rust.

## Contributing

Contributions are welcome! Areas for improvement:

- Additional security checks
- More custom lints
- IDE integrations
- Enhanced reporting formats

## License

MIT License - See [LICENSE](LICENSE-MIT) for details.

## Acknowledgments

- **Created with Claude Opus 4.6** as a demonstration of AI building validation tools for AI-generated code
- Built with [syn](https://github.com/dtolnay/syn) for Rust AST analysis
- Integrates [cargo-audit](https://github.com/rustsec/rustsec), [cargo-deny](https://github.com/EmbarkStudios/cargo-deny), and [cargo-geiger](https://github.com/geiger-rs/cargo-geiger)
- Inspired by the Rust community's commitment to safety and correctness

---

<div align="center">

**An early experiment in AI-validated tooling for AI-generated code. Built to spark conversation and gather feedback from the Rust community.**

**We need your testing and validation to make this idea real. ğŸ¦€**

[Report a Bug](https://github.com/OutsideTheBoxIdeas/UltraRust/issues) â€¢ [Request a Feature](https://github.com/OutsideTheBoxIdeas/UltraRust/issues) â€¢ [Share Your Experience](https://github.com/OutsideTheBoxIdeas/UltraRust/discussions)

**Found this useful? Star the repo to help spread the word!**

</div>
